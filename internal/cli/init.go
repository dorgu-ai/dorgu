package cli

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/spf13/cobra"
)

var initCmd = &cobra.Command{
	Use:   "init [path]",
	Short: "Initialize a .dorgu.yaml configuration file",
	Long: `Initialize a .dorgu.yaml configuration file for your application.

This command creates a .dorgu.yaml file with sensible defaults
and prompts you for key information about your application.

Examples:
  dorgu init                    # Initialize in current directory
  dorgu init ./my-app           # Initialize in specified directory
  dorgu init --minimal          # Create minimal config
  dorgu init --full             # Create full config with all options`,
	Args: cobra.MaximumNArgs(1),
	RunE: runInit,
}

var (
	initMinimal bool
	initFull    bool
	initForce   bool
)

func init() {
	initCmd.Flags().BoolVar(&initMinimal, "minimal", false, "Create minimal configuration")
	initCmd.Flags().BoolVar(&initFull, "full", false, "Create full configuration with all options")
	initCmd.Flags().BoolVar(&initForce, "force", false, "Overwrite existing .dorgu.yaml")
}

func runInit(cmd *cobra.Command, args []string) error {
	// Determine target path
	targetPath := "."
	if len(args) > 0 {
		targetPath = args[0]
	}

	// Check if path exists
	if _, err := os.Stat(targetPath); os.IsNotExist(err) {
		return fmt.Errorf("path does not exist: %s", targetPath)
	}

	// Check if config already exists
	configPath := filepath.Join(targetPath, ".dorgu.yaml")
	if _, err := os.Stat(configPath); err == nil && !initForce {
		return fmt.Errorf(".dorgu.yaml already exists. Use --force to overwrite")
	}

	var config string
	var err error

	if initMinimal {
		config = generateMinimalConfig()
	} else if initFull {
		config = generateFullConfig()
	} else {
		// Interactive mode
		config, err = interactiveInit()
		if err != nil {
			return err
		}
	}

	// Write config file
	if err := os.WriteFile(configPath, []byte(config), 0644); err != nil {
		return fmt.Errorf("failed to write config: %w", err)
	}

	fmt.Printf("Created %s\n", configPath)
	fmt.Println("\nNext steps:")
	fmt.Println("  1. Review and customize the configuration")
	fmt.Println("  2. Run: dorgu generate " + targetPath)

	return nil
}

func interactiveInit() (string, error) {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println("Dorgu Configuration Setup")
	fmt.Println("==========================")
	fmt.Println()

	// App name
	appName := prompt(reader, "Application name", filepath.Base(mustGetwd()))

	// App description
	description := prompt(reader, "Description", "")

	// Team
	team := prompt(reader, "Team name", "")

	// Owner
	owner := prompt(reader, "Owner email", "")

	// App type
	appType := prompt(reader, "Application type (api/web/worker/cron)", "api")

	// Environment
	env := prompt(reader, "Environment (production/staging/development)", "production")

	// Repository
	repo := prompt(reader, "Repository URL", "")

	// Generate config
	config := fmt.Sprintf(`# Dorgu Application Configuration
# Generated by: dorgu init
# Documentation: https://github.com/dorgu-ai/dorgu

version: "1"

app:
  name: "%s"
  description: "%s"
  team: "%s"
  owner: "%s"
  type: "%s"
  repository: "%s"
  
  # Custom instructions for AI analysis (optional)
  # instructions: |
  #   Add context about your application here.
  #   This helps generate better manifests and documentation.

environment: "%s"

# Resource configuration (optional - defaults based on app type)
# resources:
#   requests:
#     cpu: "100m"
#     memory: "256Mi"
#   limits:
#     cpu: "1000m"
#     memory: "1Gi"

# Scaling configuration (optional)
# scaling:
#   min_replicas: 2
#   max_replicas: 10
#   target_cpu: 70

# Health check configuration (optional)
# health:
#   liveness:
#     path: "/health"
#     port: 8080
#   readiness:
#     path: "/ready"
#     port: 8080

# Custom labels (optional)
# labels:
#   "app.kubernetes.io/component": "backend"

# Custom annotations (optional)
# annotations:
#   "prometheus.io/scrape": "true"

# Dependencies (optional)
# dependencies:
#   - name: postgresql
#     type: database
#     required: true
#   - name: redis
#     type: cache
#     required: false
`,
		appName,
		description,
		team,
		owner,
		appType,
		repo,
		env,
	)

	return config, nil
}

func generateMinimalConfig() string {
	return `# Dorgu Application Configuration (Minimal)
version: "1"

app:
  name: ""           # Required: application name
  description: ""    # Brief description
  team: ""           # Team responsible
  type: "api"        # api, web, worker, cron
`
}

func generateFullConfig() string {
	return `# Dorgu Application Configuration (Full)
# Documentation: https://github.com/dorgu-ai/dorgu

version: "1"

# Application metadata
app:
  name: "my-service"
  description: "Service description"
  team: "my-team"
  owner: "team@company.com"
  repository: "https://github.com/company/my-service"
  type: "api"  # api, web, worker, cron, daemon
  
  # Custom instructions for AI analysis
  instructions: |
    Add context about your application here.
    This helps generate better manifests and documentation.
    
    Include:
    - What the application does
    - Key dependencies and why they're needed
    - Performance requirements
    - SLA expectations

# Environment
environment: "production"

# Resource configuration
resources:
  requests:
    cpu: "100m"
    memory: "256Mi"
  limits:
    cpu: "1000m"
    memory: "1Gi"

# Scaling configuration
scaling:
  min_replicas: 2
  max_replicas: 10
  target_cpu: 70
  target_memory: 80

# Custom labels
labels:
  "app.kubernetes.io/component": "backend"
  "company.com/tier": "standard"

# Custom annotations
annotations:
  "prometheus.io/scrape": "true"
  "prometheus.io/port": "8080"
  "prometheus.io/path": "/metrics"

# Ingress configuration
ingress:
  enabled: true
  host: "api.company.com"
  paths:
    - path: "/api/v1"
      path_type: "Prefix"
  tls:
    enabled: true
    secret_name: "api-tls-secret"

# Health check configuration
health:
  liveness:
    path: "/health"
    port: 8080
    initial_delay: 15
    period: 10
  readiness:
    path: "/ready"
    port: 8080
    initial_delay: 5
    period: 5

# Dependencies
dependencies:
  - name: postgresql
    type: database
    required: true
  - name: redis
    type: cache
    required: true
  - name: user-service
    type: service
    required: false

# Operational information
operations:
  runbook: "https://wiki.company.com/runbooks/my-service"
  alerts:
    - "ServiceHighLatency"
    - "ServiceErrorRate"
  maintenance_window: "Sundays 02:00-04:00 UTC"
  on_call: "oncall@company.com"
`
}

func prompt(reader *bufio.Reader, label, defaultVal string) string {
	if defaultVal != "" {
		fmt.Printf("%s [%s]: ", label, defaultVal)
	} else {
		fmt.Printf("%s: ", label)
	}

	input, _ := reader.ReadString('\n')
	input = strings.TrimSpace(input)

	if input == "" {
		return defaultVal
	}
	return input
}

func mustGetwd() string {
	wd, err := os.Getwd()
	if err != nil {
		return "my-app"
	}
	return wd
}
